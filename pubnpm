#!/bin/bash

# Run a command.  Handle verbose and dry-run options.
#
# run_cmd cmd [args...]
#
run_cmd() {
   if [ $VERBOSE = true -o $DRY_RUN = true ]; then
      echo "$@"
   fi
   if [ $DRY_RUN = false ]; then
      "$@"
      if [ $? -ne 0 ]; then
         echo "ERROR: Command failed: $@"
         exit 1
      fi
   fi
}

help_gnu() {
  echo "Usage: pubnpm [OPTION] [major | minor | patch]

CHANGELOG.md must be the only modified file in the working tree.

Options:
  -h             Show help.
  -v, --verbose  Verbose execution.
  -n, --dry-run  Dry run.
  -t, --tag=TAG  Use npm publish tag.
  -b, --branch=BRANCH
                 Ensure git branch (default: master, empty string to skip).
  -N, --new      Skip owner check for a new package.
" 1>&2
  exit
}

help_not_gnu() {
  echo "Usage: pubnpm [OPTION] [major | minor | patch]

CHANGELOG.md must be the only modified file in the working tree.

Options:
  -h  Show help.
  -v  Verbose execution.
  -n  Dry run.
  -t  Use npm publish tag.
  -b  Ensure git branch (default: master, empty string to skip).
  -N  Skip owner check for a new package.
" 1>&2
  exit
}

help() {
  if [ "$GNU_GETOPT" = true ]; then
    help_gnu
  else
    help_not_gnu
  fi
}

# check getopt version
out=$(getopt -T)
if (( $? != 4 )) && [[ -n $out ]]; then
  GNU_GETOPT=false
else
  GNU_GETOPT=true
fi

if [ "$GNU_GETOPT" = true ]; then
  OPTS=`getopt -o hvnt:b:N -l help,verbose,dry-run,tag:,branch:,new -n 'pubnpm' -- "$@"`
  if [ $? != 0 ] ; then echo "ERROR: Failed parsing options." >&2 ; exit 1 ; fi
  eval set -- "$OPTS"
else
  OPTS=`getopt hvnt:b:N $*`
  if [ $? != 0 ] ; then echo "ERROR: Failed parsing options." >&2 ; exit 1 ; fi
  eval set -- "$OPTS"
fi

VERBOSE=false
DRY_RUN=false
TAG=
BRANCH=master
NEW=false

while true; do
  case "$1" in
    -h|--help) help ;;
    -v|--verbose) VERBOSE=true; shift ;;
    -n|--dry-run) DRY_RUN=true; shift ;;
    -t|--tag) TAG="$2"; shift; shift ;;
    -b|--branch) BRANCH="$2"; shift; shift ;;
    -N|--new) NEW=true; shift ;;
    --) shift; break ;;
    *) break ;;
  esac
done

VERSION_TYPE=$1

if [[ ! -e package.json ]]; then
  echo 'ERROR: package.json file does not exist.  Aborting.'
  exit 1
fi
PACKAGE_NAME=$(node -p "require('./package.json').name")
PACKAGE_REPO=$(node -p "require('./package.json').repository.url")
PACKAGE_DIR=${PWD}
RELEASE_FOLDER="/tmp/digital-bazaar-release"
NPM_WHOAMI=$(npm whoami)
if [ -z "$VERSION_TYPE" ] || ! [[ "$VERSION_TYPE" =~ ^(major|minor|patch)$ ]]; then
  echo 'ERROR: A release type must be specified: [major | minor | patch]'
  exit 1
fi
if [[ "$PACKAGE_NAME" == *\/* ]] || [[ "$PACKAGE_NAME" == *\\* ]]; then
  echo 'ERROR: Slashes detected in package name.  Aborting.'
  exit 1
fi

if [ "$VERBOSE" = true ]; then
  echo DRY_RUN=$DRY_RUN
  echo TAG=$TAG
  echo BRANCH=$BRANCH
  echo VERSION_TYPE=$VERSION_TYPE
  echo PACKAGE_NAME=$PACKAGE_NAME
  echo PACKAGE_REPO=$PACKAGE_REPO
  echo PACKAGE_DIR=$PACKAGE_DIR
  echo RELEASE_FOLDER=$RELEASE_FOLDER
  echo NPM_WHOAMI=$NPM_WHOAMI
fi

if [ "$NEW" = true ]; then
  if [ "$VERBOSE" = true ]; then
    echo "# NOTE: skipping owner check"
  fi
else
  # check npm ownership access
  # always run, even in dry-run mode
  if [ "$VERBOSE" = true ]; then
    echo "# NOTE: checking NPM package ownership"
  fi
  NPM_OWNS=$(npm owner ls | cut -d ' ' -f 1 | grep ^$NPM_WHOAMI$)

  if [ x"$NPM_WHOAMI" = x"$NPM_OWNS" ]; then
    if [ "$VERBOSE" = true ]; then
      echo "# NOTE: NPM package ownership check passed"
    fi
  else
    echo "ERROR: NPM pacakge ownership check failed"
    if [ "$DRY_RUN" = true ]; then
      echo "# NOTE: Continuing in dry-run mode with failed NPM ownership check"
    else
      exit 1
    fi
  fi
fi

# check git branch
# always run, even in dry-run mode
if [ "$VERBOSE" = true ]; then
  echo "# NOTE: checking git branch"
fi

if [ x"$BRANCH" = x ]; then
  if [ "$VERBOSE" = true ]; then
    echo "# NOTE: git branch check skipped via options"
  fi
else
  # newer git
  #GIT_BRANCH=$(git branch --show-current)
  GIT_BRANCH=$(git rev-parse --abbrev-ref HEAD)
  if [ x"$BRANCH" = x"$GIT_BRANCH" ]; then
    if [ "$VERBOSE" = true ]; then
      echo "# NOTE: git branch check passed"
    fi
  else
    echo "ERROR: git branch check failed (not on \"$BRANCH\")"
    if [ "$DRY_RUN" = true ]; then
      echo "# NOTE: Continuing in dry-run mode with failed git branch check"
    else
      exit 1
    fi
  fi
fi

# prepare release folder
if [ ! -d "${RELEASE_FOLDER}" ]; then
  run_cmd mkdir -p "${RELEASE_FOLDER}"
  if [ $? -ne 0 ]; then
    echo "ERROR: Could not create release folder.  Aborting."
    exit 1
  fi
fi
howmany() { echo $#; }
# other is added here to capture a new changelog
MODIFIED_FILES=$(git ls-files --modified --other --exclude-standard)
if [[ $(howmany $MODIFIED_FILES) != "1" ]] || [ "$MODIFIED_FILES" != "CHANGELOG.md" ]; then
  echo "Modified files:" ${MODIFIED_FILES}
  echo "ERROR: CHANGELOG.md must be the ONLY modified file.  Aborting."
  exit 1
fi
# if changelog is new, it must be added to tracked files
run_cmd git add CHANGELOG.md
run_cmd git commit -m 'Update changelog.'
run_cmd npm version $VERSION_TYPE -m 'Release %s.'
run_cmd git push
run_cmd git push --tags
NEW_VERSION=$(node -p "require('./package.json').version")
run_cmd cd "${RELEASE_FOLDER}"
run_cmd rm -rf ${PACKAGE_NAME}
echo '# NOTE: Waiting two seconds...'
run_cmd sleep 2
run_cmd git clone $PACKAGE_REPO ${PACKAGE_NAME}
run_cmd cd ${PACKAGE_NAME}
if [ $DRY_RUN = true ]; then
   echo "# NOTE: The following version is the old version due to dry-run mode."
fi
run_cmd git checkout tags/v${NEW_VERSION}
# if convention of a "build" target exists, assume an install is needed
if [ $(node -p "'build' in (require('./package.json').scripts || {})") = true ]; then
  echo '"build" script found, running install...'
  run_cmd npm install
fi
if [ x"$TAG" = x ]; then
  run_cmd npm publish
else
  run_cmd npm publish --tag $TAG
fi
run_cmd cd ${PACKAGE_DIR}
run_cmd npm version prepatch -m 'Start %s.'
DEV_VERSION=$(node -p "require('./package.json').version")
if [ $DRY_RUN = true ]; then
   echo "# NOTE: The following version is the old version due to dry-run mode."
fi
run_cmd git tag -d v${DEV_VERSION}
run_cmd git push
